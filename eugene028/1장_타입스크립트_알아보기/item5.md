# item5: any 타입 지양하기
저번 프로젝트 때 any 남발했다가 스스로 죄책감 느끼고 후회하며 코드를 많이 고쳤기 때문에 그 기억을 되살리면서 이번 item을 읽었더니 더욱 재미있었다. ㅋ.ㅋ

>타입스크립트의 타입 시스템은 점진적이고, 선택적이다.

이 말을 풀어 쓰자면 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이고, 언제든지 타입 체커를 해제할수 있기 때문에 선택적이다. 이 기능은 `any` 때문에 설명하게 된 것이라고 할 수 있다.
내가 처음에 any를 썼던 것도, 어떤 타입이 들어가는지 잘 모르겠어서, 그리고 귀찮아서 (..) 그랬었다.
부득이하게 any를 사용한다고 해도 어떤 위험성이 존재하는지 잘 알고 쓰는게 맞지 않겠는가..!!

## any 타입에는 타입 안정성이 없다.
```ts
let age: number;
age = '12'
```
any를 사용하게 되면 해당 코드도 에러 없이 잘 수행된다.
직관적으로 age에는 `number`타입을 사용하는 것이 맞다. 그러나 이러한 상황에는 `string`을 대입해도 에러가 생기지 않아서 혼돈을 야기한다.

## any는 함수 시그니처를 무시해 버린다.
함수를 작성할 때에는 시그니처를 명시하고 꼭 지켜야 한다.
- 어떤 타입의 입력을 제공받을 것인지?
- 어떤 타입의 출력을 반환할 것인지?

any를 사용하면 이 약속을 어기게 된다. 오류 없이 실행된다고 해도 다른 곳에서 문제를 일으킬 수 있으므로 주의 깊게 생각하고 사용하자.

## any타입에는 언어 서비스가 적용되지 않는다
타입스크립트 언어는 자동완성 기능을 제공해주는데, any를 사용하면 아무 도움을 받지 못한다.
그리고 타입 포맷팅과 이름을 수정해주는 기능도 이용할 수 없다.

## any타입은 코드 리팩토링 때 버그를 감춘다.
```ts
interface ComponentProps {
  onSelectItem: (item: any) => void;
}
```
콜백이 있는 컴포넌트일 때,
```ts
function renderSelector(props: ComponentProps) {/*...*/}
let selectedId: number = 0;
function handleSelectedItem(item: any){
  selectedId = item.id;
}
renderSelector({onSelectItem: handleSelectItem});
```
여기서, `onSelectItem`에 아이템 객체를 필요한 부분만 전달하는 , 즉 id만 전달하게끔 컴포넌트를 개선해보자.
```ts
interface ComopnentProps {
  onSelectItem: (id:number) => void;
}
```
이렇게 개선을 하였는데, `handleSelectedItem`은 `any`를 받아서 id를 전달받아도 문제가 없다고 나온다. 하지만, **타입 체커**를 통과를 하기는 하지만, 런타임에는 오류가 발생하게 되는 상황이 발생할 수 있다.
만약, item을 any로 미리 설정해뒀다면, **타입 체커가** 컴파일 시간에 사전에 미리 에러를  발견했을 것이다!

## any는 타입 설계를 감춘다.
애플리케이션 상태 같은 객체를 정의하는 것은 매우 복잡하다.
상태 객체 안의 타입을 일일이 작성할 때 any를 사용하면 안된다.
특히, 객체를 정의할 때에는 **상태 객체의 설계**를 감춰버리게 되므로, 협업시에 매우 큰 어려움이 생기며 동료가 코드를 이해하고 설계를 이해하는 데 어렵게 만들어버린다.

## any는 타입시스템의 신뢰를 떨어뜨린다.
사람은 실수를 하기 때문에 타입 체커가 실수를 잡아준다.
하지만 any를 사용하게 되면 타입 체커도 타입 오류를 잡지 못하여서 *신뢰할 수 없는 상황*이 되어버린다.
그렇기 때문에 any타입 사용을 지양하여 타입에 발견될 오류를 미리 잡아서 신뢰도를 높일 수 있다. 
