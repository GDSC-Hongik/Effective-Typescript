## *아이템 21 타입 넓히기*

*런타임에 모든 변수는 유일한 값을 가진다.*

*타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에는 변수는 가능한 값들의 집합인 타입을 가진다.*

*상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야한다.*

*이는 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야한다는 것인데, 이 과정을 타입스크립트에서는 ‘넓히기’라고 부른다.*

*아래 코드는 런타임에 오류 없이 실행되지만, 편집기에서는 오류가 표시된다.*

*getComponent 함수는 두 번째 매개 변수로 ‘x’|’y’|’z’ 타입을 기대했지만, x의 타입은 할당 시점에 넓히기가 동작해서 string으로 추론되었다.*

*string 타입은 ‘x’|’y’|’z’ 타입에 할당이 불가능하여 오류가 발생했다.*

```jsx
interface Vector3 {
    x: number;
    y: number;
    z: number;
}

function getComponent (vector: Vector3, axis: 'x' | 'y' | 'z') {
    return vector[axis];
}

let x = 'x';
let vec = { x: 10, y: 20, z: 30};

getComponent(vec, x);
// ~ 'string' 형식의 인수는 'x'|'y'|'z'
// 형식의 매개변수에 할당될 수 없다.
```

*타입 넓히기 진행 시 해당 값만으로 추론 가능한 타입이 여러 개이기 때문에 과정이 모호하다.*

*따라서 변수가 어떤 타입으로 추론되어야 하는지 타입스크립트는 작성자의 의도를 추측한다.*

*타입스크립트는 넓히기의 과정을 제어할 수 있는 방법을 제공한다.*

*let 대신 const로 변수를 선언하면 더 좁은 타입이 된다.*

*이전 코드에서 let으로 선언한 x를 const로 선언하면 더 좁은 타입이 돼서 앞서 발생한 오류가 해결된다.*

*이는 x가 재할당될 수 없기 때문에 타입스크립트는 더 좁은 타입인 ‘x’로 추론하는 것이다.*

*다만, 객체와 배열의 경우, (const mixed=[’x’, 1])과 같은 예제에서는 const만으로는 타입 추론 문제가 해결되지 않는다.*

```jsx
const x = 'x';  // 타입이 'x'
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x);
```

*v의 타입은 구체적인 정도에 따라 다양하게 추론될 수 있다.*

*가장 구체적인 경우: {readonly x: 1}*

*조금 추상적인 경우: {x: number}*

*가장 추상적인 경우: {[key: string]: number}/object*

*객체에서 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다.*

*⇒ v의 타입은 {x: number}가 된다.*

*⇒ v.x를 다른 숫자로는 재할당이 가능하지만 string으로는 불가능하다. 또한, 다른 속성을 추가하지도 못하기 때문에 객체를 한 번에 만들어야 한다.*

```jsx
const v = {
	x: 1,
}

v.x = 3;
v.x = '3';
// ~'3' 형식은 'number' 형식에 할당할 수 없다.
v.y = 4;
// ~ '{x: number;}' 형식에 'y' 속성이 없다.
v.name = 'Pythagoras';
// ~ '{x: number;}' 형식에 'name' 속성이 없다.
```

*타입스크립트는 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야하지만, 잘못된 추론을 할 정도로 구체적으로 수행하지는 않아 명확성과 유연성 사이 균형을 유지하려고 한다.*

*타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야한다.*

1. *명시적 타입 구문 제공하기*
    
    ```jsx
    const v: { x: 1|3|5 } = {
    	x: 1
    }  // 타입이 { x: 1|3|5 }
    ```
    
2. *타입 체커에 추가적인 문맥 제공하기 (함수 매개 변수로 값 전달)*
3. *const 단언문 사용하기*
    
    *값 뒤에 as const 작성 시 타입스크립트는 최대한 좁은 타입으로 추론한다.*
    
    ```jsx
    const v1 = {
        x: 1,
        y: 2
    };  // 타입은 { x: number, y: number }
    
    const v2 = {
        x: 1 as const,
        y: 2,
    }  // 타입은 { x: 1, y: number }
    
    const v3 = {
        x: 1,
        y: 2
    } as const;  // 타입은 { readonly x: 1; readonly y: 2; }
    ```
    
    ```jsx
    const a1 = [1, 2, 3];  // 타입이 nuber[]
    const a2 = [1, 2, 3] as const;  // 타입이 readonly [1, 2, 3]
    ```