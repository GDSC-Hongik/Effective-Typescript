## *아이템 15 동적 데이터에 인덱스 시그니처 사용하기*

*자바스크립트 객체는 문자열 키를 타입의 값에 관계 없이 매핑한다.*

*타입스크립트에서는 타입에 ‘인덱스 시그니처’를 명시해서 유연하게 매핑을 표현할 수 있다.*

*아래 코드에서 인덱스 시그니처는 세 가지 의미를 담고 있다.*

*키의 이름은 키의 위치만 표시하는 용도이고 타입 체커에서는 사용하지 않는 참고 정보 정도로 생각하면 된다.*

*키의 타입은 string이나 number 또는 symbol의 조합이어야하지만 보통은 string을 사용한다.*

*값의 타입은 어떤 것이든 될 수 있다.*

*이렇게 타입 체크 수행 시 여러 단점이 있다.*

*잘못된 키를 포함한 모든 키를 허용한다.*

*특정 키가 필요하지 않다. {}도 Rocket 타입으로 유효하다.*

*키마다 다른 타입을 가질 수 없다.*

*타입스크립트 언어 서비스인 자동 완성 기능이 제대로 동작하지 못한다.*

```jsx
type Rocket = { [property: string]: string; };

const rocket: Rocket = {
    name: 'Falcon 9',
    variant: 'v1.0',
    thrust: '4,940 kN',
};
```

*이를 인터페이스를 이용해서 나타내면 타입스크립트에서 제공하는 언어 서비스를 모두 사용할 수 있게 된다.*

*인덱스 시그니처는 동적 데이터를 표현할 때 사용한다.*

*CSV 파일처럼 헤더 행에 열 이름이 있고, 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내는 경우 사용하면 좋다.*

*열 이름이 뭔지 알 방법이 없는 경우 인덱스 시그니처를 이용하고, 열 이름을 아는 상황에서는 미리 선언해 둔 타입으로 단언문을 사용한다.*

*다만, 선언해 둔 열들이 런타임에 실제로 일치한다는 보장이 없고 값 타입에 undefined를 추가할 수 있다.*

*연관 배열의 경우, 객체에 인덱스 시그니처를 사용하는 대신 Map 타입을 사용하는 것을 고려할 수 있다.*

*어떤 타입에 가능한 필드가 제한되어 있는 경우에는 인덱스 시그니처로 모델링하면 안 된다.*

*데이터에 A, B, C, D 같은 키가 존재하지만 얼마나 많이 있는지 모른다면 선택적 필드나 유니온 타입으로 모델링하면 된다.*

```jsx
interface Row1 {[column: string]: number;};  // 너무 광범위함
interface Row2 {a: number; b?: number; c?: number;d?: number };
```

*string 타입이 너무 광범위해서 인덱스 시그니처를 사용하는데 문제가 있는 경우 두 가지 대안이 있다.*

1. *Record를 이용한다. Record는 키 타입에 유연성을 제공하는 제너릭 타입이다. string의 부분 집합을 사용할 수 있다.*

```jsx
type Vec3D = Record<'x' | 'y' | 'z', number>;

//type Vec3D = {
//	x: number;
//	y: number;
//	z: number;
//}
```

2. *매핑된 타입을 이용한다. 매핑된 타입은 키마다 별도의 타입을 사용하게 해 준다.*

```jsx
type Vec3D = {[k in 'x'|'y'|'z']: number;};

type ABC = {[k in 'a'|'b'|'c']: k extends 'b' ? string : number;};
// type ABC = {
//   a: number;
//   b: string;
//   c: number;
```

*가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.*